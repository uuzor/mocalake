Smart Accounts
Smart accounts are the primary interface for blockchain interactions in AIR Kit. The smart account is always used when interacting with the AIR Account, while the MPC (Multi-Party Computation) wallet only acts as a signer. AIR Kit provides methods to check deployment status and deploy smart accounts when needed.

Key Technical Details:

Smart accounts are chain-specific - deployment status and operations depend on the currently selected chain
If a smart account is not deployed and your dApp triggers a transaction, AIR Kit will automatically bundle the smart account deployment with the transaction
Smart account deployments are sponsored by AIR Kit via paymaster policy, so users don't need to pay gas fees for deployment
isSmartAccountDeployed()
Checks whether the user's smart account has been deployed on the currently selected blockchain.

Method Signature:


public async isSmartAccountDeployed(): Promise<boolean>
Returns:

true if the smart account is deployed on the current chain
false if the smart account is not yet deployed on the current chain
Requirements:

User must be logged in
User must be on a supported chain
deploySmartAccount()
Deploys the user's smart account to the currently selected blockchain. This method explicitly deploys the smart account, though deployment will also happen automatically when needed.

Method Signature:


public async deploySmartAccount(): Promise<{ txHash: string }>
Returns:


{
  txHash: string; // The transaction hash of the deployment transaction
}
What happens during deployment:

Checks if the smart account is already deployed on the current chain (throws error if already deployed)
Creates a deployment transaction that sends to the zero address with no value
Submits the transaction to the blockchain using the sponsored paymaster
Returns the transaction hash for tracking
Requirements:

User must be logged in
User must be on a supported chain
Smart account must not already be deployed on the current chain
Example:


try {
  const { txHash } = await airService.deploySmartAccount();
} catch (error) {
  console.error("Smart account deployment failed:", error);
  // Handle error appropriately
}
Important Notes:

Deployment is sponsored by AIR Kit - users don't pay gas fees for deployment
The deployment transaction may take some time to be confirmed on the blockchain
After deployment, the user will be able to perform blockchain operations on this chain
Automatic bundling: If you don't explicitly deploy and trigger a transaction, deployment will be automatically bundled with the transaction
Smart Account Deployment Flow
When working with smart accounts, you have two approaches:

Option 1: Explicit Deployment (Recommended for better UX)


const isDeployed = await airService.isSmartAccountDeployed();
if (!isDeployed) {
  const { txHash } = await airService.deploySmartAccount();
  // Wait for deployment confirmation before proceeding
}
Option 2: Let AIR Kit Handle Deployment Automatically Simply proceed with your transaction - deployment will be bundled automatically if needed.

Recommendation: Use Option 1 for better user experience, as it allows you to show deployment progress and handle any deployment-specific errors separately from your main transaction logic.

#2
allet Functions
AIR Kit provides comprehensive wallet functionality that allows you to interact with blockchain networks, manage smart accounts, and perform transactions. The wallet system is built on top of EIP-1193 standards and supports multiple blockchain networks.

Wallet Preloading
preloadWallet()
Preloads the wallet service to improve performance by initializing the wallet infrastructure before it's needed.

Method Signature:


public async preloadWallet(): Promise<void>
Usage:


try {
  await airService.preloadWallet();
  console.log("Wallet preloaded successfully");
} catch (error) {
  console.error("Failed to preload wallet:", error);
}
Important notes:

The wallet can be preloaded even before the user is logged in
Improves response time for subsequent wallet operations
Even if preloading hasn't finished, using the provider or any other wallet operation will ensure that the wallet is done initializing before executing the actual call
Requirements:

Service must be initialized
EIP-1193 Wallet Provider
getProvider()
Returns an EIP-1193 compatible provider that works seamlessly with popular Web3 libraries such as web3, ethers, and Viem.

Method Signature:


getProvider(): EIP1193Provider
Returns: An EIP-1193 compatible provider object with the following interface:


interface EIP1193Provider {
  request(request: AirProviderParameters): Promise<unknown>;
  on<EventName extends keyof EIP1193EventMap>(
    event: EventName,
    listener: EIP1193EventMap[EventName]
  ): void;
  removeListener<EventName extends keyof EIP1193EventMap>(
    event: EventName,
    listener: EIP1193EventMap[EventName]
  ): void;
}
Supported Events:


type EIP1193EventMap = {
  accountsChanged(accounts: string[]): void;
  chainChanged(chainId: string): void;
  connect(connectInfo: ProviderConnectInfo): void;
  disconnect(error: ProviderRpcError): void;
  message(message: ProviderMessage): void;
};
Requirements:

User must be logged in
Standard RPC Methods
The provider also supports all standard EIP-1193 methods:


// Get accounts
const accounts = await provider.request({ method: "eth_accounts" });

// Request accounts
const accounts = await provider.request({ method: "eth_requestAccounts" });

// Get chain ID
const chainId = await provider.request({ method: "eth_chainId" });

// Send transaction
const txHash = await provider.request({
  method: "eth_sendTransaction",
  params: [transactionParams]
});

// Sign message
const signature = await provider.request({
  method: "personal_sign",
  params: [message, address]
});

// Switch chain
await provider.request({
  method: "wallet_switchEthereumChain",
  params: [{ chainId: "0x2105" }] // Base mainnet
});

// And more standard RPC calls
Wallet Events
The EIP-1193 provider supports standard wallet events:


const provider = airService.getProvider();

// Listen for account changes
provider.on("accountsChanged", (accounts) => {
  console.log("Accounts changed:", accounts);
});

// Listen for chain changes
provider.on("chainChanged", (chainId) => {
  console.log("Chain changed to:", chainId);
});

// Listen for connection events
provider.on("connect", (connectInfo) => {
  console.log("Wallet connected:", connectInfo);
});

// Listen for disconnects
provider.on("disconnect", (error) => {
  console.log("Wallet disconnected:", error);
});

#3
Wagmi Connector
Wagmi is a collection of React Hooks containing everything you need to start working with Ethereum. @mocanetwork/airkit-connector is a connector for the popular wagmi library to help you integrate and interact with the AirService.

This package can be used to initialize a wagmi client that will seamlessly manage the interaction (wallet connection state and configuration, such as auto-connection, connectors, and ethers providers) of your dApp.

Initialization

import { http, createConfig, CreateConnectorFn } from "wagmi";
import { mainnet, sepolia } from "wagmi/chains";
import { airConnector, AirConnector, AirConnectorProperties } from "@mocanetwork/airkit-connector";

const wagmiConfig = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
  connectors: [
    airConnector({
      partnerId: {{YOUR_PARTNER_ID}},
    }),
  ],
});
Inside your (root) React component you can add the wagmi provider to the component tree.


function App() {
  return (
    <WagmiProvider config={wagmiConfig}>
      ...
    </WagmiProvider>
  );
}
Usage
Now you can access the connector in any component and interact with the wagmi connector. The AirService itself can also be accessed by casting the Connector to a union type with AirConnectorProperties or directly to AirConnector.


const { connect, connectors, error } = useConnect();
const { addresses, connector } = useAccount();

const isAirWalletConnector = (connector as Connector & AirConnectorProperties)
  ?.isMocaNetwork;
const airConnector = useMemo<AirConnector | null>(() => {
  if (isAirWalletConnector) {
    return connector;
  }
  return null;
}, [connector, isAirWalletConnector]);

const service = airConnector.airService;

#4

Supported Chains
AIR Kit supports multiple blockchain networks. The available chains depend on your partner configuration.

Mainnet Chains:

Base (Chain ID: 8453) - Default mainnet chain
BSC (Chain ID: 56)
Gnosis (Chain ID: 100)
Kaia (Chain ID: 24)
Soneium (Chain ID: 1946)
Testnet Chains:

Base Sepolia (Chain ID: 84532) - Default testnet chain
BSC Testnet (Chain ID: 97)
Gnosis Chiado (Chain ID: 10200)
Kairos (Chain ID: 24)
Soneium Minato (Chain ID: 1946)
Sepolia (Chain ID: 11155111)
Devnet Chains:

Moca Devnet (Chain ID: 5151)
Chain Configuration
Chains are configured per partner through the partner configuration:


// Partner configuration example
{
  chainId: "8453", // Default chain (Base mainnet)
  enabledChainIds: ["8453", "56", "100"] // All supported chains of that partner
}
Pager
Previous page

#5
Session Key Management (Beta)
AIR Kit extends the standard EIP-1193 provider with custom RPC methods for advanced functionality.

air_listSessionKeyScopes


const scopes = await provider.request({
  method: "air_listSessionKeyScopes",
  params: [chainId] // optional chain ID
});
// Returns: ActionPolicyInfo[]
air_grantPermissions


const result = await provider.request({
  method: "air_grantPermissions",
  params: [policies] // ActionPolicyInfo[]
});
// Returns: { compressedSessionData: string, sessionOwnerPrivateKey: string, permissionIds: Hex[] }
air_revokePermission


const txHash = await provider.request({
  method: "air_revokePermission",
  params: [permissionId] // Hex
});
// Returns: string (transaction hash)
air_executeAction


const txHash = await provider.request({
  method: 'air_executeAction',
  params: [{
    compressedSessionData: string,
    sessionOwnerPrivateKey: string,
    call: {
      data?: Hex,
      to: Address,
      value?: bigint
    }
  }]
});
// Returns: string (transaction hash)


#6
Advanced Functions (Beta)
AIR Kit extends the standard EIP-1193 provider with custom RPC methods for advanced functionality.

Note

Swap functionality, advanced DeFi operations are only supported on Base chain only.

Swap Operations (Beta)
air_getSwapQuote


const quote = await provider.request({
  method: "air_getSwapQuote",
  params: [
    {
      fromToken: string,
      toToken: string,
      fromAmount: string
    }
  ]
});
// Returns: swap quote data
air_sendSwapTransaction


const txHash = await provider.request({
  method: "air_sendSwapTransaction",
  params: [
    {
      fromToken: string,
      toToken: string,
      fromAmount: string
    }
  ]
});
// Returns: string (transaction hash)
air_showSwapUI


const txHash = await provider.request({
  method: "air_showSwapUI",
  params: []
});
// Returns: string (transaction hash)


#7
Credentials Overview
What are AIR Credentials?
AIR Credential is a universal, decentralized verifiable credential system designed for seamless use across digital applications and networks. Built on Moca Chain’s identity-focused infrastructure, it leverages zero-knowledge proof (ZKP) technology to enable users to prove claims (such as age, qualifications, or affiliations) without exposing their underlying private data. Each issued credential is securely encrypted, controlled by the user, allowing true self-sovereign identity and cross-ecosystem interoperability.

Who’s Who: Issuer, Holder, Verifier
Issuer	Holder	Verifier
Role	The entity that creates and vouches for the verifiable credential.	The individual or entity that receives and stores the credential in a digital wallet or account.	The party that requests and checks for proof of specific claims or attributes.
Key Actions	Issues and signs credentials	Stores and presents credentials	Requests and verifies proofs
Details	The issuer structures the data, digitally signs it, and sends the credential to the holder.	The holder controls how their credentials are shared, enabling privacy-first, self-sovereign identity management.	Instead of accessing the full credential, the verifier receives cryptographically-secure proof from the holder—often using zero-knowledge proofs for maximal privacy.
Examples	Universities, governments, protocols, DAOs, gaming platforms, community managers	Students, citizens, gamers, employees, community members	Employers, service providers, event organizers, online platforms, access-controlled communities
Issuer Process
Set up a Partner Account in the Developer Dashboard.
Configure General Partner settings.
Obtain an Issuer DID.
Top up Fee Wallet.
Create or search for relevant Credential Schemas.
Define Issuance Program(s).
Integrate AIR Kit to your app.
Issue Credentials for your users.
Verifier Process
Set up a Partner Account in the Developer Dashboard.
Configure General Partner settings.
Obtain an Verifier DID.
Top up Fee Wallet.
Search for relevant Credential Schemas and Issuers.
Create Verifier Program(s).
Integrate AIR Kit to your app.
Verify Credentials for your users.


#8
What is a Credential Schema?
A credential schema is a blueprint that defines the structure, data types, and validation rules for the credentials you want to issue. Think of it as a template that ensures all credentials of a particular type have consistent fields and data formats.

Schemas serve several critical purposes:

Data Consistency: Ensures all credentials of the same type have identical field structures
Validation: Defines data types and constraints for each field
Interoperability: Allows different systems to understand and process your credentials
Privacy: Enables selective disclosure of specific fields within a credential
Schema Components
A Schema Type encodes the structure of a particular Verifiable Credential (VC) by defining the type, the fields that must be included inside the VC, and a description for these fields.

Schemas are a crucial component that allows for the interoperable use of VCs across different services. Just by parsing a schema, any program can interpret the content of a Verifiable Credential without having to interact with the Issuer Party.

A schema type is made of two separate documents:

1. JSON-LD Context
The JSON-LD Context contains a description of the type and its fields, providing semantic meaning to your credential data by linking it to standardized vocabularies and ontologies.

Understanding JSON-LD Context
JSON-LD context defines the vocabulary and data types used in your credentials. It maps local field names to globally unique identifiers (URIs) that have well-defined meanings.

Here's an example of a JSON-LD Context for a MembershipPointsCredential:


{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "MembershipPointsCredential": {
        "@id": "https://your-domain.com/schemas/membership-points.json-ld#MembershipPointsCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/membership-points#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "memberId": {
            "@id": "vocab:memberId",
            "@type": "xsd:string"
          },
          "totalPoints": {
            "@id": "vocab:totalPoints",
            "@type": "xsd:integer"
          },
          "tier": {
            "@id": "vocab:tier",
            "@type": "xsd:string"
          },
          "lastUpdated": {
            "@id": "vocab:lastUpdated",
            "@type": "xsd:dateTime"
          }
        }
      }
    }
  ]
}
Key JSON-LD Context Elements
@version: Specifies the JSON-LD version (typically 1.1)
@protected: Ensures that terms cannot be overridden
@id: Maps to globally unique identifiers
@type: Specifies the data type using XML Schema types
vocab: Custom vocabulary namespace for your specific fields
xsd: XML Schema Definition namespace for standard data types
2. JSON Schema
The JSON Schema contains the validation rules for the Issuer Node, defining the structure and constraints for the credential data.

Here's an example of a JSON Schema for the MembershipPointsCredential:


{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "$metadata": {
    "uris": {
      "jsonLdContext": "https://your-domain.com/schemas/membership-points.json-ld",
      "jsonSchema": "https://your-domain.com/schemas/membership-points.json"
    }
  },
  "required": [
    "@context",
    "id",
    "type",
    "issuanceDate",
    "credentialSubject",
    "credentialSchema",
    "credentialStatus",
    "issuer"
  ],
  "properties": {
    "@context": {
      "type": ["string", "array", "object"]
    },
    "id": {
      "type": "string"
    },
    "type": {
      "type": ["string", "array"],
      "items": {
        "type": "string"
      }
    },
    "issuer": {
      "type": ["string", "object"],
      "format": "uri",
      "required": ["id"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "issuanceDate": {
      "type": "string",
      "format": "date-time"
    },
    "expirationDate": {
      "type": "string",
      "format": "date-time"
    },
    "credentialSchema": {
      "type": "object",
      "required": ["id", "type"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "credentialSubject": {
      "type": "object",
      "required": ["id", "memberId", "totalPoints", "tier"],
      "properties": {
        "id": {
          "title": "Credential Subject ID",
          "type": "string",
          "format": "uri"
        },
        "memberId": {
          "title": "Member ID",
          "type": "string",
          "description": "Unique member identifier"
        },
        "totalPoints": {
          "title": "Total Points",
          "type": "integer",
          "description": "Total accumulated membership points",
          "minimum": 0
        },
        "tier": {
          "title": "Membership Tier",
          "type": "string",
          "description": "Current membership tier based on points",
          "enum": ["bronze", "silver", "gold", "platinum"]
        },
        "lastUpdated": {
          "title": "Last Updated",
          "type": "string",
          "format": "date-time",
          "description": "When points were last updated"
        }
      }
    }
  }
}
Key JSON Schema Elements
$metadata: Contains URIs linking to both the JSON-LD context and JSON schema
required: Lists all mandatory fields for the credential
properties: Defines the structure and validation rules for each field
credentialSubject: Contains the actual credential data fields
format: Specifies validation formats (uri, date-time, etc.)
Benefits of This Two-Document Approach
Separation of Concerns: JSON-LD handles semantics, JSON Schema handles validation
Interoperability: Different systems can understand credentials using standard vocabularies
Validation: Issuer nodes can validate credential structure before issuance
Flexibility: Allows for complex validation rules while maintaining semantic clarity
Pager
Previous page
Credential Overview
Nex

#9

ommon Schema Use Cases
Here are some popular schema types you might create:

Membership Points Schema
A comprehensive example showing how to create a schema for tracking membership points and tiers.

JSON-LD Context

{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "MembershipPointsCredential": {
        "@id": "https://your-domain.com/schemas/membership-points.json-ld#MembershipPointsCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/membership-points#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "memberId": {
            "@id": "vocab:memberId",
            "@type": "xsd:string"
          },
          "totalPoints": {
            "@id": "vocab:totalPoints",
            "@type": "xsd:integer"
          },
          "tier": {
            "@id": "vocab:tier",
            "@type": "xsd:string"
          },
          "lastUpdated": {
            "@id": "vocab:lastUpdated",
            "@type": "xsd:dateTime"
          }
        }
      }
    }
  ]
}
JSON Schema

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "$metadata": {
    "uris": {
      "jsonLdContext": "https://your-domain.com/schemas/membership-points.json-ld",
      "jsonSchema": "https://your-domain.com/schemas/membership-points.json"
    }
  },
  "required": [
    "@context",
    "id",
    "type",
    "issuanceDate",
    "credentialSubject",
    "credentialSchema",
    "credentialStatus",
    "issuer"
  ],
  "properties": {
    "@context": {
      "type": ["string", "array", "object"]
    },
    "id": {
      "type": "string"
    },
    "type": {
      "type": ["string", "array"],
      "items": {
        "type": "string"
      }
    },
    "issuer": {
      "type": ["string", "object"],
      "format": "uri",
      "required": ["id"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "issuanceDate": {
      "type": "string",
      "format": "date-time"
    },
    "expirationDate": {
      "type": "string",
      "format": "date-time"
    },
    "credentialSchema": {
      "type": "object",
      "required": ["id", "type"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "credentialSubject": {
      "type": "object",
      "required": ["id", "memberId", "totalPoints", "tier"],
      "properties": {
        "id": {
          "title": "Credential Subject ID",
          "type": "string",
          "format": "uri"
        },
        "memberId": {
          "title": "Member ID",
          "type": "string",
          "description": "Unique member identifier"
        },
        "totalPoints": {
          "title": "Total Points",
          "type": "integer",
          "description": "Total accumulated membership points",
          "minimum": 0
        },
        "tier": {
          "title": "Membership Tier",
          "type": "string",
          "description": "Current membership tier based on points",
          "enum": ["bronze", "silver", "gold", "platinum"]
        },
        "lastUpdated": {
          "title": "Last Updated",
          "type": "string",
          "format": "date-time",
          "description": "When points were last updated"
        }
      }
    }
  }
}
Age Verification Schema
JSON-LD Context

{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "AgeVerificationCredential": {
        "@id": "https://your-domain.com/schemas/age-verification.json-ld#AgeVerificationCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/age-verification#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "age": {
            "@id": "vocab:age",
            "@type": "xsd:integer"
          },
          "dateOfBirth": {
            "@id": "vocab:dateOfBirth",
            "@type": "xsd:date"
          },
          "jurisdiction": {
            "@id": "vocab:jurisdiction",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
JSON Schema

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "$metadata": {
    "uris": {
      "jsonLdContext": "https://your-domain.com/schemas/age-verification.json-ld",
      "jsonSchema": "https://your-domain.com/schemas/age-verification.json"
    }
  },
  "required": [
    "@context",
    "id",
    "type",
    "issuanceDate",
    "credentialSubject",
    "credentialSchema",
    "credentialStatus",
    "issuer"
  ],
  "properties": {
    "@context": {
      "type": ["string", "array", "object"]
    },
    "id": {
      "type": "string"
    },
    "type": {
      "type": ["string", "array"],
      "items": {
        "type": "string"
      }
    },
    "issuer": {
      "type": ["string", "object"],
      "format": "uri",
      "required": ["id"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "issuanceDate": {
      "type": "string",
      "format": "date-time"
    },
    "expirationDate": {
      "type": "string",
      "format": "date-time"
    },
    "credentialSchema": {
      "type": "object",
      "required": ["id", "type"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "credentialSubject": {
      "type": "object",
      "required": ["id", "age", "dateOfBirth", "jurisdiction"],
      "properties": {
        "id": {
          "title": "Credential Subject ID",
          "type": "string",
          "format": "uri"
        },
        "age": {
          "title": "Age",
          "type": "integer",
          "description": "User's age in years",
          "minimum": 0,
          "maximum": 150
        },
        "dateOfBirth": {
          "title": "Date of Birth",
          "type": "string",
          "format": "date",
          "description": "User's date of birth"
        },
        "jurisdiction": {
          "title": "Jurisdiction",
          "type": "string",
          "description": "Legal jurisdiction for age verification"
        }
      }
    }
  }
}
Event Pass Schema
JSON-LD Context

{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "EventPassCredential": {
        "@id": "https://your-domain.com/schemas/event-pass.json-ld#EventPassCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/event-pass#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "eventName": {
            "@id": "vocab:eventName",
            "@type": "xsd:string"
          },
          "eventDate": {
            "@id": "vocab:eventDate",
            "@type": "xsd:dateTime"
          },
          "ticketType": {
            "@id": "vocab:ticketType",
            "@type": "xsd:string"
          },
          "seatNumber": {
            "@id": "vocab:seatNumber",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
JSON Schema

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "$metadata": {
    "uris": {
      "jsonLdContext": "https://your-domain.com/schemas/event-pass.json-ld",
      "jsonSchema": "https://your-domain.com/schemas/event-pass.json"
    }
  },
  "required": [
    "@context",
    "id",
    "type",
    "issuanceDate",
    "credentialSubject",
    "credentialSchema",
    "credentialStatus",
    "issuer"
  ],
  "properties": {
    "@context": {
      "type": ["string", "array", "object"]
    },
    "id": {
      "type": "string"
    },
    "type": {
      "type": ["string", "array"],
      "items": {
        "type": "string"
      }
    },
    "issuer": {
      "type": ["string", "object"],
      "format": "uri",
      "required": ["id"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "issuanceDate": {
      "type": "string",
      "format": "date-time"
    },
    "expirationDate": {
      "type": "string",
      "format": "date-time"
    },
    "credentialSchema": {
      "type": "object",
      "required": ["id", "type"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "credentialSubject": {
      "type": "object",
      "required": ["id", "eventName", "eventDate", "ticketType"],
      "properties": {
        "id": {
          "title": "Credential Subject ID",
          "type": "string",
          "format": "uri"
        },
        "eventName": {
          "title": "Event Name",
          "type": "string",
          "description": "Name of the event"
        },
        "eventDate": {
          "title": "Event Date",
          "type": "string",
          "format": "date-time",
          "description": "Date and time of the event"
        },
        "ticketType": {
          "title": "Ticket Type",
          "type": "string",
          "description": "Type of ticket",
          "enum": ["general", "vip", "backstage", "premium"]
        },
        "seatNumber": {
          "title": "Seat Number",
          "type": "string",
          "description": "Seat or section number"
        }
      }
    }
  }
}
Professional Credential Schema
JSON-LD Context

{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "ProfessionalCredential": {
        "@id": "https://your-domain.com/schemas/professional-credential.json-ld#ProfessionalCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/professional-credential#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "certificationName": {
            "@id": "vocab:certificationName",
            "@type": "xsd:string"
          },
          "issuingOrganization": {
            "@id": "vocab:issuingOrganization",
            "@type": "xsd:string"
          },
          "certificationNumber": {
            "@id": "vocab:certificationNumber",
            "@type": "xsd:string"
          },
          "issueDate": {
            "@id": "vocab:issueDate",
            "@type": "xsd:date"
          },
          "expiryDate": {
            "@id": "vocab:expiryDate",
            "@type": "xsd:date"
          },
          "credentialLevel": {
            "@id": "vocab:credentialLevel",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
JSON Schema

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "$metadata": {
    "uris": {
      "jsonLdContext": "https://your-domain.com/schemas/professional-credential.json-ld",
      "jsonSchema": "https://your-domain.com/schemas/professional-credential.json"
    }
  },
  "required": [
    "@context",
    "id",
    "type",
    "issuanceDate",
    "credentialSubject",
    "credentialSchema",
    "credentialStatus",
    "issuer"
  ],
  "properties": {
    "@context": {
      "type": ["string", "array", "object"]
    },
    "id": {
      "type": "string"
    },
    "type": {
      "type": ["string", "array"],
      "items": {
        "type": "string"
      }
    },
    "issuer": {
      "type": ["string", "object"],
      "format": "uri",
      "required": ["id"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "issuanceDate": {
      "type": "string",
      "format": "date-time"
    },
    "expirationDate": {
      "type": "string",
      "format": "date-time"
    },
    "credentialSchema": {
      "type": "object",
      "required": ["id", "type"],
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "credentialSubject": {
      "type": "object",
      "required": [
        "id",
        "certificationName",
        "issuingOrganization",
        "certificationNumber",
        "issueDate"
      ],
      "properties": {
        "id": {
          "title": "Credential Subject ID",
          "type": "string",
          "format": "uri"
        },
        "certificationName": {
          "title": "Certification Name",
          "type": "string",
          "description": "Name of the certification"
        },
        "issuingOrganization": {
          "title": "Issuing Organization",
          "type": "string",
          "description": "Organization that issued the certification"
        },
        "certificationNumber": {
          "title": "Certification Number",
          "type": "string",
          "description": "Unique certification identifier"
        },
        "issueDate": {
          "title": "Issue Date",
          "type": "string",
          "format": "date",
          "description": "Date the certification was issued"
        },
        "expiryDate": {
          "title": "Expiry Date",
          "type": "string",
          "format": "date",
          "description": "Date the certification expires"
        },
        "credentialLevel": {
          "title": "Credential Level",
          "type": "string",
          "description": "Level of certification",
          "enum": ["associate", "professional", "expert", "master"]
        }
      }
    }
  }
}


#10
chema Creation Guide
Credential schemas are the foundation of your credential issuance system. This guide will help you understand, create, and manage schemas effectively for your AIR Kit applications.

Creating Schemas with the Schema Builder
The AIR Kit Schema Builder provides an intuitive interface for creating credential schemas without requiring technical knowledge of JSON schema structures.

Step 1: Access the Schema Builder
Go to the Developer Dashboard
Navigate to the Schemas section under IssuerCreate Schema
Step 2: Create a New Schema
Click "Create New Schema"
Fill in the basic schema information:
Title: Choose a descriptive name for your schema
Type: Select or enter a category for your credential type
Description: Provide a clear explanation of what this schema represents
Step 3: Define Attributes
Click "+" to add attributes
For each attribute, specify:
Name: Field identifier (use camelCase)
Type: Choose from String, Number, Boolean, or Date
Description: Explain what this field represents
Required: Mark if the field is mandatory
Step 4: Publish Your Schema
Review your schema structure
Click "Publish" to make it available for credential creation
Note the schema ID for use in your applications
Create schema
Schema Builder Best Practices
1. Choose Descriptive Names
Use clear, descriptive names for your schema title and attributes
Avoid abbreviations that might be unclear to other developers
Example: "memberId" instead of "mem_id"
2. Provide Clear Descriptions
Write detailed descriptions for each attribute
Explain the purpose and expected format of each field
Include any validation rules or constraints
3. Use Appropriate Data Types
String: For text data, IDs, names, descriptions
Number: For numeric values, ages, quantities, scores
Boolean: For true/false values, flags, status indicators
Date: For timestamps, expiry dates, event dates
4. Consider Privacy Requirements
Only include fields that are necessary for your use case
Remember that users can selectively disclose fields
Avoid collecting sensitive data unless absolutely required
5. Plan for Future Updates
Consider how your schema might evolve over time
Use versioning to manage schema changes
Design attributes to be extensible

#11
chema Management and Versioning
As your application evolves, you may need to update your credential schemas. Understanding how to manage schema changes is crucial for maintaining compatibility and ensuring smooth operations.

Schema Versioning Strategy
When you need to modify a schema, consider these approaches:

Backward Compatible Changes
These changes don't break existing credentials:

Adding new optional attributes
Updating descriptions or metadata
Adding new schema versions
Breaking Changes
These changes require careful planning:

Removing attributes
Changing attribute data types
Making optional attributes required
Renaming attributes
Best Practices for Schema Evolution
1. Plan for Growth
JSON-LD Context v1.0:


{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "UserProfileCredential": {
        "@id": "https://your-domain.com/schemas/user-profile-v1.0.json-ld#UserProfileCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/user-profile/v1.0#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "firstName": {
            "@id": "vocab:firstName",
            "@type": "xsd:string"
          },
          "lastName": {
            "@id": "vocab:lastName",
            "@type": "xsd:string"
          },
          "email": {
            "@id": "vocab:email",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
2. Add New Fields Gradually
JSON-LD Context v1.1:


{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "UserProfileCredential": {
        "@id": "https://your-domain.com/schemas/user-profile-v1.1.json-ld#UserProfileCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/user-profile/v1.1#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "firstName": {
            "@id": "vocab:firstName",
            "@type": "xsd:string"
          },
          "lastName": {
            "@id": "vocab:lastName",
            "@type": "xsd:string"
          },
          "email": {
            "@id": "vocab:email",
            "@type": "xsd:string"
          },
          "phoneNumber": {
            "@id": "vocab:phoneNumber",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
3. Deprecate Fields Carefully
JSON-LD Context v2.0:


{
  "@context": [
    {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "UserProfileCredential": {
        "@id": "https://your-domain.com/schemas/user-profile-v2.0.json-ld#UserProfileCredential",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "vocab": "https://your-domain.com/vocab/user-profile/v2.0#",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "firstName": {
            "@id": "vocab:firstName",
            "@type": "xsd:string"
          },
          "lastName": {
            "@id": "vocab:lastName",
            "@type": "xsd:string"
          },
          "email": {
            "@id": "vocab:email",
            "@type": "xsd:string"
          },
          "phoneNumber": {
            "@id": "vocab:phoneNumber",
            "@type": "xsd:string"
          },
          "fullName": {
            "@id": "vocab:fullName",
            "@type": "xsd:string"
          }
        }
      }
    }
  ]
}
Managing Schema Updates in Production
1. Gradual Migration Strategy
Keep old schemas active during transition periods
Issue new credentials with updated schemas
Gradually phase out old schema versions
Monitor credential usage patterns
2. Communication with Users
Notify users about schema changes
Provide migration guides for credential holders
Maintain backward compatibility for verification
3. Testing Schema Changes
Test new schemas in development environment
Validate credential issuance with new schemas
Ensure verification still works with old credentials
Test selective disclosure with updated schemas
Schema Registry and Discovery
The AIR Kit provides a schema registry where you can:

Browse Available Schemas: Discover schemas created by other developers
Reuse Existing Schemas: Use well-established schemas for common use cases
Contribute Schemas: Share your schemas with the community
Next Steps
Now that you understand schema creation and JSON-LD implementation, you can:

Issue Credentials - Use your schemas to issue credentials in the Credential Issuance Quickstart
Verify Credentials - Learn how to verify credentials in the Credential Verification Quickstart
Explore Schema Registry - Browse and reuse existing schemas in the Developer Dashboard
Advanced Schema Design - Learn about complex schema patterns and advanced use cases
Pager
Previous page

#12
Issuing Credentials
The issuer is the entity responsible for creating and issuing credentials within the AIR Credential ecosystem. It defines schemas, issues Verifiable Credentials, and manages the lifecycle of credentials.

As an Issuer, you are responsible for issuing Verifiable Credentials to users. Follow these steps to integrate and manage the credential issuance process.

Step 1: Set Up an Issuance Program
Use the Developer Dashboard to create an issuance program (Issuer -> Programs).
While creating the program, search for the schema for the credentials you intend to issue, and check the attributes to be included (e.g., name, age, nationality, etc.). It is highly recommended to search for an existing schema so that credentials are interoperable across platforms and can be recognized, displayed, or verified by any verifier. If there are no suitable schemas available, please contact us, or you may create your own schema.
Publish the program and take note of the program ID.
Step 2: Collect User Data
Securely authenticate and retrieve your user's data within your existing application.

Step 3: Generate Auth Token
Generate a Partner JWT securely with your backend server, and include scope=issue to limit its scope.

Step 4: Issue Credentials
To encrypt the user's data and create a verified credential on-chain, simply call the issueCredential() function in AIR Kit.

WebFlutter

public async issueCredential({
    authToken,
    issuerDid,
    credentialId,
    credentialSubject,
}: {
    authToken: string;
    issuerDid: string;
    credentialId: string;
    credentialSubject: Record<string, unknown>;
}): Promise<void>
Parameter	Type	Description
authToken	string	Your signed Partner JWT, with scope=issue.
issuerDid	string	Your Issuer DID.
credentialId	string	Program ID for the credential being issued.
credentialSubject	Record<string, unknown>	Object containing the credential's claims and attributes for the subject.
Response: Throws an error if issuance fails.

Under the hood, AIR Kit generates a Verifiable Credential based on the issuance program and schema, pushes the VC on-chain, and stores the encrypted data in decentralized storage. During this process, the raw user data and private keys stay on the client side and are not exposed to Moca's servers.

Tips

Use the Developer Dashboard to view and manage issued credentials (Issuer -> Records). In cases where credentials need to be invalidated, use the Revoke function in the Dashboard.
Use the Chain Explorer to find the record of the on-chain transaction related to issuance (Credentials -> Issuance)
Best Practices for Issuers
Only issue credentials after thorough validation of submitted evidence or claims.
Minimize inclusion of personally identifiable information—issue privacy-preserving credentials whenever possible.
Adopt open, standardized schemas to maximize compatibility and reduce verification friction across apps.
Implement robust expiry and revocation processes, and ensure that holders and verifiers are informed of credential status.
Respect user sovereignty at all stages; credentials should be under full user control and portable across the ecosystem.

#14

Verifying Credentials
The Verifier is a key entity within the AIR Credential ecosystem, responsible for verifying the authenticity of a user’s credential and determining whether it meets predefined conditions. Leveraging zero-knowledge proofs, the Verifier can validate credentials without accessing or exposing sensitive user data.

As a Verifier, your role is to verify the authenticity of user credentials and ensure they meet the required conditions. Follow these steps to integrate and operate the verification process.

Verification Flow
The AIR Credential verification process follows these simplified steps:

Verification Request - Verifier presents a verification requirement to the user (e.g., "Prove you're over 18")
Credential Issuance (if needed) - If the user lacks the required credential, a trusted Issuer validates their information and issues an encrypted verifiable credential stored in decentralized storage
Zero-Knowledge Proof Generation - User generates a cryptographic proof from their credential that answers the verifier's query without revealing personal data
On-Chain Verification - The proof is submitted to Moca Chain's smart contract, which validates it and records the verification result
Access Granted - Upon successful verification, the user gains access to the requested service or resource
Decentralized Storage
Moca Chain
Issuer
User
Verifier
Decentralized Storage
Moca Chain
Issuer
User
Verifier
alt
[Credential not held]
1. Verification Request ("Prove you're over 18")
2a. Provides information
2b. Issues encrypted credential
2c. Credential issued
3a. Download encrypted credential
3a. Decrypt credential data
3b. Generates zero-knowledge proof
4. Submits proof for verification
4. Proof validation result
5. Access granted
Implementation
Step 1: Set Up a Verification Program
Use the Developer Dashboard to create a verification program (Verifier -> Program).
While creating the program, search for the schema for the credentials you intend to verify, and check the attributes to be included (e.g., name, age, nationality, etc.).
Use the Define Query module to set up specific verification conditions, such as:
Attributes to verify (e.g., age, nationality).
Operators (e.g., Equals, Not Equals, Includes, Excludes).
Attribute values to match.
Specify the Issuer’s DID to ensure the credentials being verified originate from a trusted issuer. (optional)
Provide a program name and review all configured details before saving.
Publish the program on-chain and take note of the program ID. You will need $MOCA in your Fee Wallet (Verifier -> Fee Wallet).
Step 2: Generate Auth Token
Generate a Partner JWT securely with your backend server, and include scope=verify to limit its scope.

Step 3: Initiate Verification Request
To verify a user's Verified Credentials, simply call the verifyCredentials() function in AIR Kit to verify a VC on-chain.

WebFlutter

public async verifyCredential({
    authToken,
    programId,
    redirectUrl,
  }: {
    authToken: string;
    programId: string;
    redirectUrl?: string;
  }): Promise<CredentialVerificationResult>
Input Parameters
Name	Type	Required	Description
authToken	string	Yes	Your signed Partner JWT, with scope=verify.
programId	string	Yes	Identifier for the verification program.
redirectUrl	string	No	Optional URL to redirect the user if the user has not issued the relevant credential.
Response
The function returns a Promise<CredentialVerificationResult>. The CredentialVerificationResult includes a status field, which can have one of the following values:

Field	Type	Description
status	string	The result of the credential verification. Possible values:
- "Compliant": Credential is valid and meets all verification requirements.
- "Non-Compliant": Credential is valid but does not meet requirements.
- "Pending": Verification is in progress or awaiting user action.
- "Revoking": Credential is in the process of being revoked.
- "Revoked": Credential has been revoked and is no longer valid.
- "Expired": Credential is no longer valid due to expiration.
- "NotFound": Credential could not be found or do not exist.
Under the hood, AIR Kit retrieves the encrypted credentials from Decentralized Storage based on the user’s wallet address and program configuration. After the user approves the verification process, a Zero-knowledge Proof (ZKP) is generated on the client side without exposing the raw data to the verifier or Moca's servers. At the same time, the credentials are checked against any revocation statuses or expiration. Once the ZKP is generated, it is submitted on-chain for verification.

Tips

Use the Chain Explorer to find the record of the on-chain transaction related to verification (Credentials -> Verification)